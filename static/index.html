<!DOCTYPE html>
<html>

<head>
    <title>WebTerminal</title>
    <link rel="stylesheet" href="./node_modules/xterm/css/xterm.css" />
    <script src="./node_modules/xterm/lib/xterm.js"></script>
    <script src="./node_modules/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
</head>

<body>
    <div id="terminal-container" style="width: 100%; height: 100vh; overflow: hidden;">
        <div id="terminal" style="width: 100%; height: 100%;"></div>
    </div>
    <script>
        // 创建终端对象
        const term = new Terminal();
        
        // 创建 FitAddon 插件
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        
        // 挂载终端对象到 id 为 "terminal" 的 div 元素
        term.open(document.querySelector('#terminal'));
       // Determine the WebSocket protocol (ws or wss) based on the current page's protocol
       const protocol = window.location.protocol === "https:" ? "wss" : "ws";
       const wsUrl = `${protocol}://${window.location.host}/xterm/webterminal`;

        // Create a new WebSocket connection
        const socket = new WebSocket(wsUrl);
        socket.binaryType = 'arraybuffer';

        // 发送终端尺寸给服务端
        function sendResize() {
            if (socket.readyState === WebSocket.OPEN) {
                const payload = JSON.stringify({ type: "resize", cols: term.cols, rows: term.rows });
                socket.send(payload);
            }
        }
        // 网页 xterm 窗口中有输入的数据
        term.onData((data) => {
            socket.send(data); // 通过 WebSocket 发送给服务器
        });
        
        // 收到来自服务器的 WebSocket 消息
        // 使用流式解码，避免多字节 UTF-8 被分帧切开导致的 "\uFFFD" 乱码
        const utf8Decoder = new TextDecoder('utf-8', { fatal: false });
        socket.onmessage = (event) => {
            let text;
            if (event.data instanceof ArrayBuffer) {
                text = utf8Decoder.decode(new Uint8Array(event.data), { stream: true });
            } else {
                text = event.data;
            }
            term.write(text);
        };

        // 连接关闭时 flush 解码器缓冲，输出任何未完成的多字节序列
        socket.addEventListener('close', () => {
            const remaining = utf8Decoder.decode();
            if (remaining) term.write(remaining);
        });
        
        // 函数：调整终端大小
        function fitTerminal() {
            fitAddon.fit();
            // 将新的行列数同步给服务端
            sendResize();
        }
        
        // 初始调整终端大小
        fitTerminal();

        // WebSocket 打开后同步一次尺寸，确保后端 PTY 与前端一致
        socket.addEventListener('open', () => {
            sendResize();
        });
        
        // 监听窗口大小变化事件，调整终端大小并同步后端 PTY 尺寸
        window.addEventListener('resize', fitTerminal);
    </script>
</body>

</html>
